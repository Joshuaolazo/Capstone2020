import math
import numpy as np
import math
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression

#points = [(x, x*np.random.randint(0,2)+x**3*np.random.randint(0,2)+x**2*np.random.randint(0,2)) for x in range(0,100)]
points = [(0,0), (0,0), (0,0), (0,0), (0.111047,0.701527), (0,0), (0.00990423,0.686347), (0.0109931,0.662571), (0.0204501,0.769784), (0.00815483,0.663314), (0.022388,0.63337), (0.00317194,0.605764), (0.0492088,0.579559), (0.0696493,0.553681), (0.0685529,0.561928), (0.0608299,0.565924), (0.0529651,0.573413), (0.0587795,0.581428), (0.0636558,0.578382), (0.07972,0.578271), (0.0784985,0.585092), (0.0736787,0.594676), (0.0706368,0.591611), (0.0623246,0.576629), (0.0516826,0.562513), (0.0251476,0.54818), (0.0160037,0.535845), (0.0154296,0.513039), (0.0169717,0.481536), (0.0235081,0.445056), (0.0199467,0.409326), (0.0202173,0.357626), (0.0302444,0.327092), (0.0459216,0.29798), (0.0877732,0.263615), (0.114544,0.260829), (0.159595,0.271791), (0.206651,0.289064), (0.247952,0.294647), (0.31221,0.320975), (0.363406,0.322246), (0.403794,0.351243), (0.459379,0.358142), (0.495627,0.360748), (0.530967,0.358319), (0.573186,0.356268), (0.603127,0.327993), (0.61085,0.288563), (0.612274,0.247594), (0.605341,0.202356), (0.608418,0.153133), (0.616245,0.108586), (0.614566,0.0651537), (0.626482,0.0325364), (0.629564,0.0142504), (0.63798,0.000435218), (0.636844,0.0064007), (0.638688,0.00652783), (0.64201,0.00622283), (0.642238,0.0133705), (0.63543,0.0112471), (0.637041,0.00945961), (0.636024,0.0114322), (0.633254,0.0411874), (0.609666,0.117649), (0.616732,0.167036), (0.55537,0.179859), (0.529172,0.603962), (0,0), (0,0), ]
points = [(x*100,y*100) for (x,y) in points]
# if (x,y) != (0,0)
print(points)
x = np.array([[point[0]/1] for point in points])
y = np.array([[point[1]/1] for point in points])

start,end = (0,0),(0,0)

if len(points)>=10:
    start =  start + ((points[0][0] + points[1][0] + points[2][0] + points[3][0]+ points[4][0])/5, (points[0][1] + points[1][1] + points[2][1] + points[3][1]+ points[4][1])/5)
    end = end + ((points[-1][0] + points[-2][0] + points[-3][0] + points[-4][0]+ points[-5][0])/5, (points[-1][1] + points[-2][1] + points[-3][1] + points[-4][1]+ points[-5][1])/5)
else:
    start = points[0]
    end = points[-1]


distance =  math.sqrt((start[0] - end[0])**2 + (start[1] - end[1])**2)//1

#notice these are signed
xdistance = end[0] - start[0]
ydistance = end[1] - start[1]

minx, miny, maxx, maxy = float('inf'),float('inf'), float('-inf'), float('-inf')
for point in points:
    if point[0]<minx:
        minx = point[0]
    elif point[0]>maxx:
        maxx = point[0]
    if point[1]<miny:
        miny = point[1]
    elif point[1]>maxy:
        maxy = point[1]

movement = False
if maxx-minx>=10 or maxy-miny>=10:
    movement = True

print(start, end, distance,xdistance,ydistance)

model = LinearRegression()
print(x.shape)
x_new = np.hstack([x,x**2,x**3,x**4])
x_new.shape
model.fit(x_new, y)
print(model.coef_)
y_pred = model.predict(x_new)
plt.scatter(x,y)
plt.plot(x_new[:,0],y_pred,'r')
plt.show()
coef = model.coef_[0]

i = np.linspace(start,end,100)
j = coef[0]*i + coef[1]*i**2 + coef[2]*i**3 + coef[3]*i**4 + model.intercept_
print(model.intercept_)
plt.plot(i,j)
plt.show()



#MOTION CONTROLS
if not movement:
    #STOP Roomba
    pass

#Closed Loop
if movement and distance<10:
    #Spin a full circle like a doggo
    pass

#Raising hand upwards/downwards with no substantial x movement
elif ydistance>15 and abs(xdistance)<15:
    #go forward
    pass
elif ydistance<-15 and abs(xdistance)<15:
    #go backwards
    pass

#Moving hand leftwards/rightwards with no substantial y movement
elif xdistance>15 and abs(ydistance)<15:
    #turn right
    pass
elif xdistance<-15 and abs(ydistance)<15:
    #turn left
    pass


#Linear Functions
elif abs(coef[1])<0.2 and abs(coef[2])<0.2 and abs(coef[3])<0.2:

    #POSITIVE LINEAR

    #Drawn bottom left -> top right
    if coef[0]>0.1 and xdistance>=0 and ydistance>=0:
        #Go Forwards with wheels angled 30 degrees to the right
        pass
    #Drawn top right->bottom left
    elif coef[0]>0.1 and xdistance<0 and ydistance<0:
        #Go Backwards with wheels angled 30 degrees to the right
        pass


    #NEGATIVE LINEAR

    #Drawn bottom right -> top left
    if coef[0]<-0.1 and xdistance>=0 and ydistance>=0:
        #Go Forwards with wheels angled 30 degrees to the left
        pass
    #Drawn top left->bottom right    
    elif coef[0]<-0.1 and xdistance<0 and ydistance<0:
        #Go Backwards with wheels angled 30 degrees to the left
        pass
    # Quadratic and x^4 // dont't care how it's drawn
elif  abs(coef[2])<0.2:

    #Positive U
    if coef[1]>=0.2 or coef[3]>=0.2 or coef[1]+coef[3]>0.3:
        #do something brooooo
        pass
    #Negative U
    elif coef[1]<=-0.2 or coef[3]<=-0.2 or coef[1]+coef[3]<-0.3:
        #do something girllll
        pass

# Cubic // don't care how it's drawn
elif abs(coef[2])>=0.2:

    if coef[2]>=0.2:
        #fetch idk
        pass
    elif coef[2]<=-0.2:
        #return to dock
        pass

#Nothing matches at all
else:
    pass







